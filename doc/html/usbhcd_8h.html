<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Memtest86+: /home/stefan/Documents/Schule/Studium/6._Semester/bsc_thesis/stgloor-memtest/system/usbhcd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Memtest86+
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e8522150b400a43ebfdbd1fed060b8e2.html">system</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">usbhcd.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides the base USB host controller driver for USB keyboard support.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="usb_8h_source.html">usb.h</a>&quot;</code><br />
</div>
<p><a href="usbhcd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structusb__ep__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a></td></tr>
<tr class="memdesc:structusb__ep__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB endpoint descriptor (used internally by the various HCI drivers).  <a href="usbhcd_8h.html#structusb__ep__t">More...</a><br /></td></tr>
<tr class="separator:structusb__ep__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structusb__parent__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#structusb__parent__t">usb_parent_t</a></td></tr>
<tr class="memdesc:structusb__parent__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB parent device descriptor (used internally by the various HCI drivers).  <a href="usbhcd_8h.html#structusb__parent__t">More...</a><br /></td></tr>
<tr class="separator:structusb__parent__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structusb__hub__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a></td></tr>
<tr class="memdesc:structusb__hub__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB hub descriptor (used internally by the various HCI drivers).  <a href="usbhcd_8h.html#structusb__hub__t">More...</a><br /></td></tr>
<tr class="separator:structusb__hub__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhcd__methods__t.html">hcd_methods_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB host controller driver method table.  <a href="structhcd__methods__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structhcd__workspace__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#structhcd__workspace__t">hcd_workspace_t</a></td></tr>
<tr class="memdesc:structhcd__workspace__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB host controller driver workspace.  <a href="usbhcd_8h.html#structhcd__workspace__t">More...</a><br /></td></tr>
<tr class="separator:structhcd__workspace__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structusb__hcd__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a></td></tr>
<tr class="memdesc:structusb__hcd__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB host controller driver object.  <a href="usbhcd_8h.html#structusb__hcd__t">More...</a><br /></td></tr>
<tr class="separator:structusb__hcd__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a993585880a7365bbd8b5ac0d346b7ce6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a993585880a7365bbd8b5ac0d346b7ce6">HCD_DATA_BUFFER_SIZE</a>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:a993585880a7365bbd8b5ac0d346b7ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the data transfer buffer in a host controller driver workspace.  <a href="usbhcd_8h.html#a993585880a7365bbd8b5ac0d346b7ce6">More...</a><br /></td></tr>
<tr class="separator:a993585880a7365bbd8b5ac0d346b7ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a77a74ee374683b1efa3c816400b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a1e8a77a74ee374683b1efa3c816400b4">HCD_KC_BUFFER_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a1e8a77a74ee374683b1efa3c816400b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the key code buffer in a host controller driver workspace.  <a href="usbhcd_8h.html#a1e8a77a74ee374683b1efa3c816400b4">More...</a><br /></td></tr>
<tr class="separator:a1e8a77a74ee374683b1efa3c816400b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1"><td class="memItemLeft" align="right" valign="top">typedef const struct usb_hcd_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1">usb_hcd_r</a></td></tr>
<tr class="memdesc:a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB host controller driver object reference.  <a href="usbhcd_8h.html#a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1">More...</a><br /></td></tr>
<tr class="separator:a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a624cde5d2f6383faa35fd05108285a23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> { <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23ac9755ae6b86f8148054fd6a342c74acc">USB_SPEED_UNKNOWN</a> = 0
, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23a0ec4f8f66feaf7ee8f2ee618302e9470">USB_SPEED_LOW</a> = 1
, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23a0f17d0b9928086c6114fea73e08f1780">USB_SPEED_FULL</a> = 2
, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23a57eeede6d769b09c01ac9c9c62fef8c9">USB_SPEED_HIGH</a> = 3
 }</td></tr>
<tr class="memdesc:a624cde5d2f6383faa35fd05108285a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB device speed (used internally by the various HCI drivers).  <a href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">More...</a><br /></td></tr>
<tr class="separator:a624cde5d2f6383faa35fd05108285a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7829cd3284024cd32ffd2c840222baa3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3">usb_init_options_t</a> { <br />
&#160;&#160;<a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3a6f2bcb231c49ecf65bd7cc1a3ba329c8">USB_DEFAULT_INIT</a> = 0
, <a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3af3f71cbb370a6ac30aa5a427fddcc1a4">USB_EXTRA_RESET</a> = 1 &lt;&lt; 0
, <a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3aa10389fa2534b94bdb068e5476f205c4">USB_IGNORE_EHCI</a> = 1 &lt;&lt; 1
, <a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3abf79edc8c6caadae4bd329ec6aab4522">USB_2_STEP_INIT</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3aa6546b3c3b452f7084c258af117c901d">USB_DEBUG</a> = 1 &lt;&lt; 3
<br />
 }</td></tr>
<tr class="memdesc:a7829cd3284024cd32ffd2c840222baa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of USB device initialisation options.  <a href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3">More...</a><br /></td></tr>
<tr class="separator:a7829cd3284024cd32ffd2c840222baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c02e8db7f7981375afb479b73e985cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a4c02e8db7f7981375afb479b73e985cf">build_setup_packet</a> (<a class="el" href="usb_8h.html#structusb__setup__pkt__t">usb_setup_pkt_t</a> *pkt, int type, int request, int value, int index, int length)</td></tr>
<tr class="memdesc:a4c02e8db7f7981375afb479b73e985cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a USB setup packet in buffer using the provided values.  <a href="usbhcd_8h.html#a4c02e8db7f7981375afb479b73e985cf">More...</a><br /></td></tr>
<tr class="separator:a4c02e8db7f7981375afb479b73e985cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15591137f1ff93a44465904971b0eead"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a15591137f1ff93a44465904971b0eead">default_max_packet_size</a> (<a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> device_speed)</td></tr>
<tr class="separator:a15591137f1ff93a44465904971b0eead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3608913e6d0080ae3ea822ebbdbf1e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#aee3608913e6d0080ae3ea822ebbdbf1e">valid_usb_max_packet_size</a> (int size, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> speed)</td></tr>
<tr class="memdesc:aee3608913e6d0080ae3ea822ebbdbf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if size is a valid value for the maximum packet size for a USB device running at the given speed.  <a href="usbhcd_8h.html#aee3608913e6d0080ae3ea822ebbdbf1e">More...</a><br /></td></tr>
<tr class="separator:aee3608913e6d0080ae3ea822ebbdbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ebccc68ac9716003a418cc0f0be87f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a05ebccc68ac9716003a418cc0f0be87f">valid_usb_device_descriptor</a> (const uint8_t *buffer)</td></tr>
<tr class="memdesc:a05ebccc68ac9716003a418cc0f0be87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if buffer appears to contain a valid USB device descriptor.  <a href="usbhcd_8h.html#a05ebccc68ac9716003a418cc0f0be87f">More...</a><br /></td></tr>
<tr class="separator:a05ebccc68ac9716003a418cc0f0be87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1c8c04b9b86179bfe4d8cf6019fa9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#ac0e1c8c04b9b86179bfe4d8cf6019fa9">valid_usb_config_descriptor</a> (const uint8_t *buffer)</td></tr>
<tr class="memdesc:ac0e1c8c04b9b86179bfe4d8cf6019fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if buffer appears to contain a valid USB configuration descriptor.  <a href="usbhcd_8h.html#ac0e1c8c04b9b86179bfe4d8cf6019fa9">More...</a><br /></td></tr>
<tr class="separator:ac0e1c8c04b9b86179bfe4d8cf6019fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acaad27de7a066a805cf5e5b85d1b2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a51acaad27de7a066a805cf5e5b85d1b2">usb_route</a> (const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *hub, int port_num)</td></tr>
<tr class="memdesc:a51acaad27de7a066a805cf5e5b85d1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the USB route to the device attached to the hub port specified by hub and port_num.  <a href="usbhcd_8h.html#a51acaad27de7a066a805cf5e5b85d1b2">More...</a><br /></td></tr>
<tr class="separator:a51acaad27de7a066a805cf5e5b85d1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339f0b8c31ef59fe59a6b4ac6d4f1b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="usbhcd_8h.html#structusb__parent__t">usb_parent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a339f0b8c31ef59fe59a6b4ac6d4f1b05">usb_hs_parent</a> (const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *hub, int port_num, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> device_speed)</td></tr>
<tr class="memdesc:a339f0b8c31ef59fe59a6b4ac6d4f1b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the high-speed parent device ID and port number (as defined by the EHCI and XHCI specifications) for the device attached to the hub port specified by hub and port_num.  <a href="usbhcd_8h.html#a339f0b8c31ef59fe59a6b4ac6d4f1b05">More...</a><br /></td></tr>
<tr class="separator:a339f0b8c31ef59fe59a6b4ac6d4f1b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5829457f339a240387aa00c71f3435ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a5829457f339a240387aa00c71f3435ea">wait_until_clr</a> (const volatile uint32_t *reg, uint32_t bit_mask, int max_time)</td></tr>
<tr class="memdesc:a5829457f339a240387aa00c71f3435ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the bits set in bit_mask to be cleared in the register pointed to by reg or for max_time microseconds to elapse.  <a href="usbhcd_8h.html#a5829457f339a240387aa00c71f3435ea">More...</a><br /></td></tr>
<tr class="separator:a5829457f339a240387aa00c71f3435ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a76c17baa3b162f8b3475afb9834c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#ae72a76c17baa3b162f8b3475afb9834c">wait_until_set</a> (const volatile uint32_t *reg, uint32_t bit_mask, int max_time)</td></tr>
<tr class="memdesc:ae72a76c17baa3b162f8b3475afb9834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all the bits set in bit_mask to also be set in the register pointed to by reg or for max_time microseconds to elapse.  <a href="usbhcd_8h.html#ae72a76c17baa3b162f8b3475afb9834c">More...</a><br /></td></tr>
<tr class="separator:ae72a76c17baa3b162f8b3475afb9834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3e5955be3bdfd7d37b23b37bf01659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#abd3e5955be3bdfd7d37b23b37bf01659">print_usb_info</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:abd3e5955be3bdfd7d37b23b37bf01659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays an informational message, scrolling the screen if necessary.  <a href="usbhcd_8h.html#abd3e5955be3bdfd7d37b23b37bf01659">More...</a><br /></td></tr>
<tr class="separator:abd3e5955be3bdfd7d37b23b37bf01659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2470645732bb221059c678ac9c70c512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a2470645732bb221059c678ac9c70c512">reset_usb_hub_port</a> (const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *hcd, const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *hub, int port_num)</td></tr>
<tr class="memdesc:a2470645732bb221059c678ac9c70c512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the specified USB hub port.  <a href="usbhcd_8h.html#a2470645732bb221059c678ac9c70c512">More...</a><br /></td></tr>
<tr class="separator:a2470645732bb221059c678ac9c70c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dcb40f0b95c82525c1f137e049b90e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#ae4dcb40f0b95c82525c1f137e049b90e">assign_usb_address</a> (const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *hcd, const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *hub, int port_num, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> device_speed, int device_id, <a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a> *ep0)</td></tr>
<tr class="memdesc:ae4dcb40f0b95c82525c1f137e049b90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the device address for the device attached to the specified hub port (thus moving the device to Address state), fills in the descriptor for the device's default control endpoint (ep0), and leaves the device descriptor in the driver's data transfer buffer.  <a href="usbhcd_8h.html#ae4dcb40f0b95c82525c1f137e049b90e">More...</a><br /></td></tr>
<tr class="separator:ae4dcb40f0b95c82525c1f137e049b90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d344ddf5b4f93ced2ccf900b21b8128"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a3d344ddf5b4f93ced2ccf900b21b8128">find_attached_usb_keyboards</a> (const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *hcd, const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *hub, int port_num, <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a> device_speed, int device_id, int *num_devices, <a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a> keyboards[], int max_keyboards, int *num_keyboards)</td></tr>
<tr class="memdesc:a3d344ddf5b4f93ced2ccf900b21b8128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the specified USB device to detect whether it has any HID keyboards attached to it (directly or indirectly).  <a href="usbhcd_8h.html#a3d344ddf5b4f93ced2ccf900b21b8128">More...</a><br /></td></tr>
<tr class="separator:a3d344ddf5b4f93ced2ccf900b21b8128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b67629c3b42103978f48157f3c6520"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a45b67629c3b42103978f48157f3c6520">process_usb_keyboard_report</a> (const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *hcd, const <a class="el" href="usb_8h.html#structhid__kbd__rpt__t">hid_kbd_rpt_t</a> *report, const <a class="el" href="usb_8h.html#structhid__kbd__rpt__t">hid_kbd_rpt_t</a> *prev_report)</td></tr>
<tr class="memdesc:a45b67629c3b42103978f48157f3c6520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the latest keyboard report from a HID keyboard for key presses that weren't present in the previous report from that keyboard.  <a href="usbhcd_8h.html#a45b67629c3b42103978f48157f3c6520">More...</a><br /></td></tr>
<tr class="separator:a45b67629c3b42103978f48157f3c6520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee83531624febe54a69a70ef39e434c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a0ee83531624febe54a69a70ef39e434c">find_usb_keyboards</a> (bool pause_if_none)</td></tr>
<tr class="memdesc:a0ee83531624febe54a69a70ef39e434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans the attached USB devices and initialises all HID keyboard devices it finds (subject to implementation limits on the number of devices).  <a href="usbhcd_8h.html#a0ee83531624febe54a69a70ef39e434c">More...</a><br /></td></tr>
<tr class="separator:a0ee83531624febe54a69a70ef39e434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ae5e3a9ad76285187783f2b4cf6282"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#a06ae5e3a9ad76285187783f2b4cf6282">get_usb_keycode</a> (void)</td></tr>
<tr class="memdesc:a06ae5e3a9ad76285187783f2b4cf6282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the keyboards discovered by find_usb_keyboards.  <a href="usbhcd_8h.html#a06ae5e3a9ad76285187783f2b4cf6282">More...</a><br /></td></tr>
<tr class="separator:a06ae5e3a9ad76285187783f2b4cf6282"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa0ff1e49014a85a25554ae5abd93c552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3">usb_init_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbhcd_8h.html#aa0ff1e49014a85a25554ae5abd93c552">usb_init_options</a></td></tr>
<tr class="memdesc:aa0ff1e49014a85a25554ae5abd93c552"><td class="mdescLeft">&#160;</td><td class="mdescRight">The selected USB device initialisation options.  <a href="usbhcd_8h.html#aa0ff1e49014a85a25554ae5abd93c552">More...</a><br /></td></tr>
<tr class="separator:aa0ff1e49014a85a25554ae5abd93c552"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Provides the base USB host controller driver for USB keyboard support. </p>
<p >This is an object-oriented design. The <a class="el" href="structhcd__methods__t.html" title="A USB host controller driver method table.">hcd_methods_t</a> structure defines a set of virtual methods that will be implemented by the subclasses. The <a class="el" href="usbhcd_8h.html#structhcd__workspace__t" title="A USB host controller driver workspace.">hcd_workspace_t</a> structure defines the base class properties. The <a class="el" href="usbhcd_8h.html#structusb__hcd__t" title="A USB host controller driver object.">usb_hcd_t</a> structure represents a driver object. The non-virtual and default base class methods are defined as separate functions, taking a <a class="el" href="usbhcd_8h.html#structusb__hcd__t" title="A USB host controller driver object.">usb_hcd_t</a> pointer as their first parameter.</p>
<p >The find_usb_keyboards function instantiates a driver object of the appropriate subclass for each USB controller it finds and stores it in the private usb_controllers table, where it can subsequently used to poll the keyboards for key presses. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structusb__ep__t" id="structusb__ep__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structusb__ep__t">&#9670;&#160;</a></span>usb_ep_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_ep_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A USB endpoint descriptor (used internally by the various HCI drivers). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ae85e93620c3b1b2c77eaa95e5a8d8af3" name="ae85e93620c3b1b2c77eaa95e5a8d8af3"></a>uintptr_t</td>
<td class="fieldname">
driver_data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a670c768e4b576fbb2cc6c9cef34cb265" name="a670c768e4b576fbb2cc6c9cef34cb265"></a><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a></td>
<td class="fieldname">
device_speed</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a418eaa332f32c93621c5d4c347541df6" name="a418eaa332f32c93621c5d4c347541df6"></a>uint8_t</td>
<td class="fieldname">
device_id</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa505229dc1960c45a10552c047147131" name="aa505229dc1960c45a10552c047147131"></a>uint8_t</td>
<td class="fieldname">
interface_num</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aae3cdeab57e64d586d825fd670ca35ee" name="aae3cdeab57e64d586d825fd670ca35ee"></a>uint8_t</td>
<td class="fieldname">
endpoint_num</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a2f696b04e22c5a83909139c8a25616aa" name="a2f696b04e22c5a83909139c8a25616aa"></a>uint16_t</td>
<td class="fieldname">
max_packet_size</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ae3fc962baa1fdc111b3f8a2efccd1954" name="ae3fc962baa1fdc111b3f8a2efccd1954"></a>uint8_t</td>
<td class="fieldname">
interval</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="acbed7a590aa42eb754db62b83b58aa7d" name="acbed7a590aa42eb754db62b83b58aa7d"></a>uint8_t</td>
<td class="fieldname">
reserved</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structusb__parent__t" id="structusb__parent__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structusb__parent__t">&#9670;&#160;</a></span>usb_parent_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_parent_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A USB parent device descriptor (used internally by the various HCI drivers). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac81f4811ed82c0ca01e86c63ac33c476" name="ac81f4811ed82c0ca01e86c63ac33c476"></a>uint8_t</td>
<td class="fieldname">
device_id</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7e05d550f220d07c1bd891296e1e75cf" name="a7e05d550f220d07c1bd891296e1e75cf"></a>uint8_t</td>
<td class="fieldname">
port_num</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structusb__hub__t" id="structusb__hub__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structusb__hub__t">&#9670;&#160;</a></span>usb_hub_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_hub_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A USB hub descriptor (used internally by the various HCI drivers). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a0dc010609d61074f74293c0c9e742d46" name="a0dc010609d61074f74293c0c9e742d46"></a>const <a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a> *</td>
<td class="fieldname">
ep0</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a9ce2ce4ce275753064fb07ea76d54d0b" name="a9ce2ce4ce275753064fb07ea76d54d0b"></a>uint32_t</td>
<td class="fieldname">
route</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a1db2f47ac532335cea8527afd88357c4" name="a1db2f47ac532335cea8527afd88357c4"></a>uint8_t</td>
<td class="fieldname">
level</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a140d5a461a05c08de9a97748c3417546" name="a140d5a461a05c08de9a97748c3417546"></a>uint8_t</td>
<td class="fieldname">
num_ports</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8c980c6d5bc259355f3fc2b664e10ec3" name="a8c980c6d5bc259355f3fc2b664e10ec3"></a>uint8_t</td>
<td class="fieldname">
tt_think_time</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6629945e4c56ea25fd3bb2471b9748a9" name="a6629945e4c56ea25fd3bb2471b9748a9"></a>uint8_t</td>
<td class="fieldname">
power_up_delay</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a3cd82d78c399177c69d982b2c823d08c" name="a3cd82d78c399177c69d982b2c823d08c"></a><a class="el" href="usbhcd_8h.html#structusb__parent__t">usb_parent_t</a></td>
<td class="fieldname">
hs_parent</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a985d35a9a0fb314659fe93754246374e" name="a985d35a9a0fb314659fe93754246374e"></a>uint16_t</td>
<td class="fieldname">
reserved</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structhcd__workspace__t" id="structhcd__workspace__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structhcd__workspace__t">&#9670;&#160;</a></span>hcd_workspace_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct hcd_workspace_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A USB host controller driver workspace. </p>
<p >This is extended by each HCI driver to append its private data. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a08f9a90f883ff1e7b8cf0fef72b5ab35" name="a08f9a90f883ff1e7b8cf0fef72b5ab35"></a>uint8_t</td>
<td class="fieldname">
data_buffer[<a class="el" href="usbhcd_8h.html#a993585880a7365bbd8b5ac0d346b7ce6">HCD_DATA_BUFFER_SIZE</a>]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7cfa5c28b4e7c13e493bc9de1fe69755" name="a7cfa5c28b4e7c13e493bc9de1fe69755"></a>size_t</td>
<td class="fieldname">
data_length</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8634ccb3a49677b6c142af4c83af3ef8" name="a8634ccb3a49677b6c142af4c83af3ef8"></a>uint8_t</td>
<td class="fieldname">
kc_buffer[<a class="el" href="usbhcd_8h.html#a1e8a77a74ee374683b1efa3c816400b4">HCD_KC_BUFFER_SIZE</a>]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="adb518855de5da75669e2a8e04ae3edf8" name="adb518855de5da75669e2a8e04ae3edf8"></a>int8_t</td>
<td class="fieldname">
kc_index_i</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa329bf3593ce0a87596c5d0be13a55e2" name="aa329bf3593ce0a87596c5d0be13a55e2"></a>int8_t</td>
<td class="fieldname">
kc_index_o</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structusb__hcd__t" id="structusb__hcd__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structusb__hcd__t">&#9670;&#160;</a></span>usb_hcd_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct usb_hcd_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >A USB host controller driver object. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6d129b19a3d0bc9189006b720a595548" name="a6d129b19a3d0bc9189006b720a595548"></a>const <a class="el" href="structhcd__methods__t.html">hcd_methods_t</a> *</td>
<td class="fieldname">
methods</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a6290e99494e7b67474d826921ec06a13" name="a6290e99494e7b67474d826921ec06a13"></a><a class="el" href="usbhcd_8h.html#structhcd__workspace__t">hcd_workspace_t</a> *</td>
<td class="fieldname">
ws</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a993585880a7365bbd8b5ac0d346b7ce6" name="a993585880a7365bbd8b5ac0d346b7ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993585880a7365bbd8b5ac0d346b7ce6">&#9670;&#160;</a></span>HCD_DATA_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HCD_DATA_BUFFER_SIZE&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the data transfer buffer in a host controller driver workspace. </p>

</div>
</div>
<a id="a1e8a77a74ee374683b1efa3c816400b4" name="a1e8a77a74ee374683b1efa3c816400b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8a77a74ee374683b1efa3c816400b4">&#9670;&#160;</a></span>HCD_KC_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HCD_KC_BUFFER_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the key code buffer in a host controller driver workspace. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1" name="a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1">&#9670;&#160;</a></span>usb_hcd_r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const struct usb_hcd_s* <a class="el" href="usbhcd_8h.html#a4cff5d3fc4fe43b5d4dd9ad2c39fc5e1">usb_hcd_r</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A USB host controller driver object reference. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a624cde5d2f6383faa35fd05108285a23" name="a624cde5d2f6383faa35fd05108285a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624cde5d2f6383faa35fd05108285a23">&#9670;&#160;</a></span>usb_speed_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A USB device speed (used internally by the various HCI drivers). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a624cde5d2f6383faa35fd05108285a23ac9755ae6b86f8148054fd6a342c74acc" name="a624cde5d2f6383faa35fd05108285a23ac9755ae6b86f8148054fd6a342c74acc"></a>USB_SPEED_UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a624cde5d2f6383faa35fd05108285a23a0ec4f8f66feaf7ee8f2ee618302e9470" name="a624cde5d2f6383faa35fd05108285a23a0ec4f8f66feaf7ee8f2ee618302e9470"></a>USB_SPEED_LOW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a624cde5d2f6383faa35fd05108285a23a0f17d0b9928086c6114fea73e08f1780" name="a624cde5d2f6383faa35fd05108285a23a0f17d0b9928086c6114fea73e08f1780"></a>USB_SPEED_FULL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a624cde5d2f6383faa35fd05108285a23a57eeede6d769b09c01ac9c9c62fef8c9" name="a624cde5d2f6383faa35fd05108285a23a57eeede6d769b09c01ac9c9c62fef8c9"></a>USB_SPEED_HIGH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7829cd3284024cd32ffd2c840222baa3" name="a7829cd3284024cd32ffd2c840222baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7829cd3284024cd32ffd2c840222baa3">&#9670;&#160;</a></span>usb_init_options_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3">usb_init_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of USB device initialisation options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7829cd3284024cd32ffd2c840222baa3a6f2bcb231c49ecf65bd7cc1a3ba329c8" name="a7829cd3284024cd32ffd2c840222baa3a6f2bcb231c49ecf65bd7cc1a3ba329c8"></a>USB_DEFAULT_INIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7829cd3284024cd32ffd2c840222baa3af3f71cbb370a6ac30aa5a427fddcc1a4" name="a7829cd3284024cd32ffd2c840222baa3af3f71cbb370a6ac30aa5a427fddcc1a4"></a>USB_EXTRA_RESET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7829cd3284024cd32ffd2c840222baa3aa10389fa2534b94bdb068e5476f205c4" name="a7829cd3284024cd32ffd2c840222baa3aa10389fa2534b94bdb068e5476f205c4"></a>USB_IGNORE_EHCI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7829cd3284024cd32ffd2c840222baa3abf79edc8c6caadae4bd329ec6aab4522" name="a7829cd3284024cd32ffd2c840222baa3abf79edc8c6caadae4bd329ec6aab4522"></a>USB_2_STEP_INIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7829cd3284024cd32ffd2c840222baa3aa6546b3c3b452f7084c258af117c901d" name="a7829cd3284024cd32ffd2c840222baa3aa6546b3c3b452f7084c258af117c901d"></a>USB_DEBUG&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4c02e8db7f7981375afb479b73e985cf" name="a4c02e8db7f7981375afb479b73e985cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c02e8db7f7981375afb479b73e985cf">&#9670;&#160;</a></span>build_setup_packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void build_setup_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usb_8h.html#structusb__setup__pkt__t">usb_setup_pkt_t</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a USB setup packet in buffer using the provided values. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a15591137f1ff93a44465904971b0eead" name="a15591137f1ff93a44465904971b0eead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15591137f1ff93a44465904971b0eead">&#9670;&#160;</a></span>default_max_packet_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int default_max_packet_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>device_speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aee3608913e6d0080ae3ea822ebbdbf1e" name="aee3608913e6d0080ae3ea822ebbdbf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3608913e6d0080ae3ea822ebbdbf1e">&#9670;&#160;</a></span>valid_usb_max_packet_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool valid_usb_max_packet_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if size is a valid value for the maximum packet size for a USB device running at the given speed. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a05ebccc68ac9716003a418cc0f0be87f" name="a05ebccc68ac9716003a418cc0f0be87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ebccc68ac9716003a418cc0f0be87f">&#9670;&#160;</a></span>valid_usb_device_descriptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool valid_usb_device_descriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if buffer appears to contain a valid USB device descriptor. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="ac0e1c8c04b9b86179bfe4d8cf6019fa9" name="ac0e1c8c04b9b86179bfe4d8cf6019fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1c8c04b9b86179bfe4d8cf6019fa9">&#9670;&#160;</a></span>valid_usb_config_descriptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool valid_usb_config_descriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if buffer appears to contain a valid USB configuration descriptor. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a51acaad27de7a066a805cf5e5b85d1b2" name="a51acaad27de7a066a805cf5e5b85d1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acaad27de7a066a805cf5e5b85d1b2">&#9670;&#160;</a></span>usb_route()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usb_route </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the USB route to the device attached to the hub port specified by hub and port_num. </p>
<p >The top 8 bits of the returned value contain the root port number and the bottom 20 bits contain the USB3 route string.</p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a339f0b8c31ef59fe59a6b4ac6d4f1b05" name="a339f0b8c31ef59fe59a6b4ac6d4f1b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339f0b8c31ef59fe59a6b4ac6d4f1b05">&#9670;&#160;</a></span>usb_hs_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="usbhcd_8h.html#structusb__parent__t">usb_parent_t</a> usb_hs_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>device_speed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the high-speed parent device ID and port number (as defined by the EHCI and XHCI specifications) for the device attached to the hub port specified by hub and port_num. </p>
<p >Returns zero values if the device is operating at high speed (as specified by device_speed) or is directly attached to a root hub port.</p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a5829457f339a240387aa00c71f3435ea" name="a5829457f339a240387aa00c71f3435ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5829457f339a240387aa00c71f3435ea">&#9670;&#160;</a></span>wait_until_clr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_until_clr </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bit_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all the bits set in bit_mask to be cleared in the register pointed to by reg or for max_time microseconds to elapse. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="ae72a76c17baa3b162f8b3475afb9834c" name="ae72a76c17baa3b162f8b3475afb9834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a76c17baa3b162f8b3475afb9834c">&#9670;&#160;</a></span>wait_until_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_until_set </td>
          <td>(</td>
          <td class="paramtype">const volatile uint32_t *&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bit_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all the bits set in bit_mask to also be set in the register pointed to by reg or for max_time microseconds to elapse. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="abd3e5955be3bdfd7d37b23b37bf01659" name="abd3e5955be3bdfd7d37b23b37bf01659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3e5955be3bdfd7d37b23b37bf01659">&#9670;&#160;</a></span>print_usb_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_usb_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays an informational message, scrolling the screen if necessary. </p>
<p >Takes the same arguments as the printf function.</p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a2470645732bb221059c678ac9c70c512" name="a2470645732bb221059c678ac9c70c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2470645732bb221059c678ac9c70c512">&#9670;&#160;</a></span>reset_usb_hub_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reset_usb_hub_port </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *&#160;</td>
          <td class="paramname"><em>hcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the specified USB hub port. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="ae4dcb40f0b95c82525c1f137e049b90e" name="ae4dcb40f0b95c82525c1f137e049b90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dcb40f0b95c82525c1f137e049b90e">&#9670;&#160;</a></span>assign_usb_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool assign_usb_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *&#160;</td>
          <td class="paramname"><em>hcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>device_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a> *&#160;</td>
          <td class="paramname"><em>ep0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the device address for the device attached to the specified hub port (thus moving the device to Address state), fills in the descriptor for the device's default control endpoint (ep0), and leaves the device descriptor in the driver's data transfer buffer. </p>
<p >Returns true if all actions are successfully completed.</p>
<p >This is the default implementation of the HCD assign_address method. </p>

</div>
</div>
<a id="a3d344ddf5b4f93ced2ccf900b21b8128" name="a3d344ddf5b4f93ced2ccf900b21b8128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d344ddf5b4f93ced2ccf900b21b8128">&#9670;&#160;</a></span>find_attached_usb_keyboards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool find_attached_usb_keyboards </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *&#160;</td>
          <td class="paramname"><em>hcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hub__t">usb_hub_t</a> *&#160;</td>
          <td class="paramname"><em>hub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#a624cde5d2f6383faa35fd05108285a23">usb_speed_t</a>&#160;</td>
          <td class="paramname"><em>device_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_devices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="usbhcd_8h.html#structusb__ep__t">usb_ep_t</a>&#160;</td>
          <td class="paramname"><em>keyboards</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_keyboards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_keyboards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the specified USB device to detect whether it has any HID keyboards attached to it (directly or indirectly). </p>
<p >If so, the keyboard device(s) are initialised and configured, as are any intermediate USB hubs, and the table defined by keyboards and max_keyboards is updated accordingly and num_keyboards is updated to match. Returns true if any keyboards were found and added to the table.</p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a45b67629c3b42103978f48157f3c6520" name="a45b67629c3b42103978f48157f3c6520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b67629c3b42103978f48157f3c6520">&#9670;&#160;</a></span>process_usb_keyboard_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool process_usb_keyboard_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="usbhcd_8h.html#structusb__hcd__t">usb_hcd_t</a> *&#160;</td>
          <td class="paramname"><em>hcd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="usb_8h.html#structhid__kbd__rpt__t">hid_kbd_rpt_t</a> *&#160;</td>
          <td class="paramname"><em>report</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="usb_8h.html#structhid__kbd__rpt__t">hid_kbd_rpt_t</a> *&#160;</td>
          <td class="paramname"><em>prev_report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the latest keyboard report from a HID keyboard for key presses that weren't present in the previous report from that keyboard. </p>
<p >Appends the HID key code for each new key press to the driver's key code buffer. Returns false if the report signals the phantom condition, otherwise returns true.</p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
<a id="a0ee83531624febe54a69a70ef39e434c" name="a0ee83531624febe54a69a70ef39e434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee83531624febe54a69a70ef39e434c">&#9670;&#160;</a></span>find_usb_keyboards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_usb_keyboards </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause_if_none</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans the attached USB devices and initialises all HID keyboard devices it finds (subject to implementation limits on the number of devices). </p>
<p >Records the information needed to subsequently poll those devices for key presses.</p>
<p >Used internally by keyboard.c. </p>

</div>
</div>
<a id="a06ae5e3a9ad76285187783f2b4cf6282" name="a06ae5e3a9ad76285187783f2b4cf6282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ae5e3a9ad76285187783f2b4cf6282">&#9670;&#160;</a></span>get_usb_keycode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t get_usb_keycode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the keyboards discovered by find_usb_keyboards. </p>
<p >Consumes and returns the HID key code for the first key press it detects. Returns zero if no key has been pressed.</p>
<p >Used internally by keyboard.c. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa0ff1e49014a85a25554ae5abd93c552" name="aa0ff1e49014a85a25554ae5abd93c552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ff1e49014a85a25554ae5abd93c552">&#9670;&#160;</a></span>usb_init_options</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="usbhcd_8h.html#a7829cd3284024cd32ffd2c840222baa3">usb_init_options_t</a> usb_init_options</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The selected USB device initialisation options. </p>
<p >Used internally by the various HCI drivers. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
